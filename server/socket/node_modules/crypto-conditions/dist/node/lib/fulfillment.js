"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js-stable/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _typeRegistry = _interopRequireDefault(require("./type-registry"));

var _condition = _interopRequireDefault(require("./condition"));

var _base64url = _interopRequireDefault(require("../util/base64url"));

var _fulfillment = require("../schemas/fulfillment");

/**
 * @module types
 */

/**
 * Base class for fulfillment types.
 */
var Fulfillment = /*#__PURE__*/function () {
  function Fulfillment() {
    (0, _classCallCheck2.default)(this, Fulfillment);
  }

  (0, _createClass2.default)(Fulfillment, [{
    key: "getTypeId",
    value:
    /**
     * Return the type ID of this fulfillment.
     *
     * @return {Number} Type ID as an integer.
     */
    function getTypeId() {
      return this.constructor.TYPE_ID;
    }
  }, {
    key: "getTypeName",
    value: function getTypeName() {
      return this.constructor.TYPE_NAME;
    }
    /**
     * Return the bitmask of this fulfillment.
     *
     * For simple fulfillment types this is simply the empty set.
     *
     * For compound fulfillments, this returns the set of names of all
     * subfulfillment types, recursively.
     *
     * @return {Set<String>} Set of subtype names.
     */

  }, {
    key: "getSubtypes",
    value: function getSubtypes() {
      return new _set.default();
    }
    /**
     * Generate condition corresponding to this fulfillment.
     *
     * An important property of crypto-conditions is that the condition can always
     * be derived from the fulfillment. This makes it very easy to post
     * fulfillments to a system without having to specify which condition the
     * relate to. The system can keep an index of conditions and look up any
     * matching events related to that condition.
     *
     * @return {Condition} Condition corresponding to this fulfillment.
     */

  }, {
    key: "getCondition",
    value: function getCondition() {
      var condition = new _condition.default();
      condition.setHash(this.generateHash());
      condition.setTypeId(this.getTypeId());
      condition.setCost(this.calculateCost());
      condition.setSubtypes(this.getSubtypes());
      return condition;
    }
    /**
     * Shorthand for getting condition URI.
     *
     * Stands for getCondition().serializeUri().
     *
     * @return {String} Condition URI.
     */

  }, {
    key: "getConditionUri",
    value: function getConditionUri() {
      return this.getCondition().serializeUri();
    }
    /**
     * Shorthand for getting condition encoded as binary.
     *
     * Stands for getCondition().serializeBinary().
     *
     * @return {Buffer} Binary encoded condition.
     */

  }, {
    key: "getConditionBinary",
    value: function getConditionBinary() {
      return this.getCondition().serializeBinary();
    }
    /**
     * Generate the hash of the fulfillment.
     *
     * This method is a stub and will be overridden by subclasses.
     *
     * @return {Buffer} Fingerprint of the condition.
     *
     * @private
     */

  }, {
    key: "generateHash",
    value: function generateHash() {
      throw new Error('This method should be implemented by a subclass');
    }
    /**
     * Calculate the cost of the fulfillment payload.
     *
     * Each condition type has a standard deterministic formula for estimating the
     * cost of validating the fulfillment. This is an abstract function which will
     * be overridden by each of the types with the actual formula.
     *
     * @return {Number} Cost
     *
     * @private
     */

  }, {
    key: "calculateCost",
    value: function calculateCost() {
      throw new Error('Condition types must implement calculateCost');
    }
  }, {
    key: "parseAsn1JsonPayload",
    value: function parseAsn1JsonPayload(json) {
      this.parseJson(json);
    }
    /**
     * Generate the URI form encoding of this fulfillment.
     *
     * Turns the fulfillment into a URI containing only URL-safe characters. This
     * format is convenient for passing around fulfillments in URLs, JSON and
     * other text-based formats.
     *
     * @return {String} Fulfillment as a URI
     */

  }, {
    key: "serializeUri",
    value: function serializeUri() {
      return _base64url.default.encode(this.serializeBinary());
    }
  }, {
    key: "getAsn1Json",
    value: function getAsn1Json() {
      return {
        type: this.constructor.TYPE_ASN1_FULFILLMENT,
        value: this.getAsn1JsonPayload()
      };
    }
    /**
     * Serialize fulfillment to a buffer.
     *
     * Encodes the fulfillment as a string of bytes. This is used internally for
     * encoding subfulfillments, but can also be used to passing around
     * fulfillments in a binary protocol for instance.
     *
     * @return {Buffer} Serialized fulfillment
     */

  }, {
    key: "serializeBinary",
    value: function serializeBinary() {
      var asn1Json = this.getAsn1Json();
      return _fulfillment.Fulfillment.encode(asn1Json);
    }
  }, {
    key: "serializeBase64Url",
    value: function serializeBase64Url() {
      return _base64url.default.encode(this.serializeBinary());
    }
    /**
     * Validate this fulfillment.
     *
     * This implementation is a stub and will be overridden by the subclasses.
     *
     * @return {Boolean} Validation result
     */

  }, {
    key: "validate",
    value: function validate() {
      throw new Error('Not implemented');
    }
  }], [{
    key: "fromUri",
    value:
    /**
     * Create a Fulfillment object from a URI.
     *
     * This method will parse a fulfillment URI and construct a corresponding
     * Fulfillment object.
     *
     * @param {String} serializedFulfillment URI representing the fulfillment
     * @return {Fulfillment} Resulting object
     */
    function fromUri(serializedFulfillment) {
      if (serializedFulfillment instanceof Fulfillment) {
        return serializedFulfillment;
      } else if (typeof serializedFulfillment !== 'string') {
        throw new TypeError('Serialized fulfillment must be a string');
      }

      var fulfillment = Fulfillment.fromBinary(Buffer.from(serializedFulfillment, 'base64'));
      return fulfillment;
    }
    /**
     * Create a Fulfillment object from a binary blob.
     *
     * This method will parse a stream of binary data and construct a
     * corresponding Fulfillment object.
     *
     * @param {Buffer} data Binary buffer
     * @return {Fulfillment} Resulting object
     */

  }, {
    key: "fromBinary",
    value: function fromBinary(data) {
      var fulfillmentJson = _fulfillment.Fulfillment.decode(data);

      return Fulfillment.fromAsn1Json(fulfillmentJson);
    }
  }, {
    key: "fromAsn1Json",
    value: function fromAsn1Json(json) {
      var FulfillmentClass = _typeRegistry.default.findByAsn1FulfillmentType(json.type).Class;

      var condition = new FulfillmentClass();
      condition.parseAsn1JsonPayload(json.value);
      return condition;
    }
  }, {
    key: "fromJson",
    value: function fromJson(json) {
      var ConditionClass = _typeRegistry.default.findByName(json.type).Class;

      var condition = new ConditionClass();
      condition.parseJson(json);
      return condition;
    }
  }]);
  return Fulfillment;
}();

var _default = Fulfillment;
exports.default = _default;